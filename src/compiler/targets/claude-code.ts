import { writeFile, ensureDir, resolvePath } from '../../utils/filesystem.js';
import { logger } from '../../utils/logger.js';
// Template engine available for future Handlebars-based compilation
import type { IntermediateRepresentation } from '../assembler.js';
import type { Config } from '../../utils/config.js';

interface ClaudeCodeOutput {
  claudeMd: string;
  commands: Map<string, string>;
  settingsJson: string;
}

function buildSettingsJson(config: Config): string {
  const hooksPath = '.ai-engineering/hooks';

  const settings: Record<string, unknown> = {};

  if (config.level === 'strict') {
    settings.hooks = {
      'PreToolUse': [
        {
          matcher: '.*',
          hooks: [`bash ${hooksPath}/pre-tool.sh`],
        },
      ],
      'PostToolUse': [
        {
          matcher: '.*',
          hooks: [`bash ${hooksPath}/post-tool.sh`],
        },
      ],
      'Startup': [
        {
          hooks: [`bash ${hooksPath}/version-check.sh`],
        },
      ],
    };
  }

  return JSON.stringify(settings, null, 2);
}

function buildCommands(ir: IntermediateRepresentation): Map<string, string> {
  const commands = new Map<string, string>();

  const skillMap: Record<string, { name: string; description: string }> = {
    'git/commit': { name: 'ai-commit', description: 'Verified commit with quality checks' },
    'git/pr': { name: 'ai-pr', description: 'Create a pull request with structured review' },
    'git/git': { name: 'ai-git', description: 'Git Way-of-Working: cleanup, health, full report' },
    'sdlc/implement': { name: 'ai-implement', description: 'Guided implementation workflow' },
    'sdlc/review': { name: 'ai-review', description: 'Structured code review' },
    'quality/security-audit': { name: 'ai-security', description: 'Security audit' },
    'learning/explain': { name: 'ai-explain', description: 'Feynman-style code explanation' },
  };

  for (const [key, content] of ir.skillSections) {
    const mapping = skillMap[key];
    if (mapping) {
      commands.set(mapping.name, content);
    }
  }

  return commands;
}

function buildClaudeMd(ir: IntermediateRepresentation): string {
  const sections: string[] = [];

  // Header
  sections.push('# Project Standards — ai-engineering');
  sections.push('');
  sections.push(`> Generated by ai-engineering v${ir.config.version} on ${new Date().toISOString().split('T')[0]}`);
  sections.push(`> Stacks: ${ir.config.stacks.join(', ')} | Level: ${ir.config.level}`);
  sections.push('');

  // Danger zone
  sections.push('## DANGER ZONE — Absolute Rules');
  sections.push('');
  sections.push('These rules are NON-NEGOTIABLE. Violation will be blocked by runtime hooks and git hooks.');
  sections.push('');
  sections.push('- **NEVER** use `git push --force` or `git push -f` to any branch');
  sections.push(`- **NEVER** commit directly to protected branches: ${ir.config.branches.protectedBranches.join(', ')}`);
  sections.push('- **NEVER** commit files matching: `.env*`, `*.pem`, `*.key`, `credentials*`, `*secret*`');
  sections.push('- **NEVER** use `--no-verify` flag on any git command');
  sections.push('- **NEVER** hardcode secrets, tokens, passwords, or API keys');
  sections.push('- **NEVER** use `rm -rf` on project root, `.git/`, or `node_modules/` without explicit user request');
  sections.push('- **NEVER** disable TypeScript strict mode or ESLint rules');
  sections.push('- **ALWAYS** run tests after code changes');
  sections.push('- **ALWAYS** use conventional commit format');
  sections.push('');

  // Compliance branches
  sections.push('## Compliance Branches');
  sections.push('');
  sections.push(`- **${ir.config.branches.defaultBranch}**: Production. No direct pushes. Requires PR + review + all checks.`);
  sections.push(`- **${ir.config.branches.developBranch}**: Integration. Requires PR + checks.`);
  sections.push('- **release/\\***: Release prep. PR to default branch required.');
  sections.push('- **hotfix/\\***: Emergency fixes. Push allowed, must PR to default + develop.');
  sections.push('- **dev/\\***: Feature branches. No restrictions.');
  sections.push('');

  // Standards
  sections.push(ir.assembled.standards);
  sections.push('');

  // Security
  sections.push('## Security Standards');
  sections.push('');
  sections.push(ir.assembled.security);
  sections.push('');

  // Git conventions
  sections.push('## Git Conventions');
  sections.push('');
  sections.push(ir.assembled.git);
  sections.push('');

  // Testing
  sections.push('## Testing Standards');
  sections.push('');
  sections.push(ir.assembled.testing);
  sections.push('');

  // Agents
  sections.push(ir.assembled.agents);
  sections.push('');

  // Skills
  sections.push(ir.assembled.skills);
  sections.push('');

  // Available commands
  sections.push('## Available Commands');
  sections.push('');
  sections.push('Use these slash commands for guided workflows:');
  sections.push('');
  sections.push('| Command | Description |');
  sections.push('|---------|-------------|');
  sections.push('| `/ai-commit` | Verified commit with quality checks |');
  sections.push('| `/ai-pr` | Create PR with structured review |');
  sections.push('| `/ai-implement` | Guided implementation workflow |');
  sections.push('| `/ai-review` | Structured code review |');
  sections.push('| `/ai-security` | Security audit |');
  sections.push('| `/ai-git` | Git Way-of-Working (cleanup, health, full) |');
  sections.push('| `/ai-explain` | Feynman-style code explanation |');
  sections.push('');

  // Knowledge
  sections.push('## Project Knowledge');
  sections.push('');
  sections.push('The `.ai-engineering/knowledge/` directory contains project-specific knowledge:');
  sections.push('- `learnings.md` — Lessons learned during development');
  sections.push('- `patterns.md` — Project-specific patterns and conventions');
  sections.push('- `anti-patterns.md` — Known mistakes to avoid in this project');
  sections.push('- `decisions/` — Architecture Decision Records (ADRs)');
  sections.push('');
  sections.push('Read these files at the start of each session to understand project context.');
  sections.push('');

  // Multi-IDE Sync
  sections.push('## Multi-IDE Sync');
  sections.push('');
  sections.push('This project uses ai-engineering with section markers. If you modify the TEAM section');
  sections.push('of this file, check if other IDE instruction files exist and update their TEAM sections');
  sections.push('to keep them in sync:');
  sections.push('- `.github/copilot-instructions.md`');
  sections.push('- `codex.md`');

  return sections.join('\n');
}

export function compileClaudeCode(
  ir: IntermediateRepresentation,
  _projectRoot: string,
): ClaudeCodeOutput {
  logger.info('Compiling Claude Code target...');

  const claudeMd = buildClaudeMd(ir);
  const commands = buildCommands(ir);
  const settingsJson = buildSettingsJson(ir.config);

  return { claudeMd, commands, settingsJson };
}

export function writeClaudeCodeOutput(
  output: ClaudeCodeOutput,
  projectRoot: string,
): void {
  // Write commands
  const commandsDir = resolvePath(projectRoot, '.claude/commands');
  ensureDir(commandsDir);

  for (const [name, content] of output.commands) {
    writeFile(resolvePath(commandsDir, `${name}.md`), content);
  }
  logger.success(`Generated ${output.commands.size} slash commands in .claude/commands/`);

  // Write settings.json
  const settingsPath = resolvePath(projectRoot, '.claude/settings.json');
  writeFile(settingsPath, output.settingsJson);
  logger.success('Generated .claude/settings.json');
}
