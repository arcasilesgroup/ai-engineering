import { rmSync } from "node:fs";
import {
  writeFile,
  ensureDir,
  resolvePath,
  listFiles,
} from "../../utils/filesystem.js";
import { logger } from "../../utils/logger.js";
// Template engine available for future Handlebars-based compilation
import type { IntermediateRepresentation } from "../assembler.js";
import type { Config } from "../../utils/config.js";

interface ClaudeCodeOutput {
  claudeMd: string;
  commands: Map<string, string>;
  settingsJson: string;
}

function buildSettingsJson(_config: Config): string {
  const hooksPath = "$CLAUDE_PROJECT_DIR/.ai-engineering/hooks";

  const settings: Record<string, unknown> = {};

  settings.permissions = {
    allow: [
      "Bash(gh:*)",
      "Bash(az:*)",
      "Bash(npx prettier:*)",
      "Bash(npx eslint:*)",
      "Bash(npm test:*)",
      "Bash(npm run:*)",
    ],
  };

  settings.hooks = {
    PreToolUse: [
      {
        matcher: "Bash",
        hooks: [
          { type: "command", command: `bash ${hooksPath}/pre-tool.sh` },
          {
            type: "command",
            command: `bash ${hooksPath}/warn-branch-origin.sh`,
          },
        ],
      },
      {
        matcher: "Edit|Write",
        hooks: [{ type: "command", command: `bash ${hooksPath}/pre-tool.sh` }],
      },
    ],
    PostToolUse: [
      {
        matcher: "Edit|Write",
        hooks: [{ type: "command", command: `bash ${hooksPath}/post-tool.sh` }],
      },
    ],
    SessionStart: [
      {
        matcher: "startup",
        hooks: [
          { type: "command", command: `bash ${hooksPath}/version-check.sh` },
        ],
      },
    ],
  };

  return JSON.stringify(settings, null, 2);
}

function buildCommands(ir: IntermediateRepresentation): Map<string, string> {
  const commands = new Map<string, string>();

  const skillMap: Record<string, { name: string; description: string }> = {
    "git/ship": {
      name: "ai-ship",
      description: "Commit + push (+ PR with auto-merge)",
    },
    "git/git": {
      name: "ai-git",
      description: "Git Way-of-Working: cleanup, health, full report",
    },
    "sdlc/implement": {
      name: "ai-implement",
      description: "Guided implementation workflow",
    },
    "sdlc/review": { name: "ai-review", description: "Structured code review" },
    "quality/security-audit": {
      name: "ai-security",
      description: "Security audit",
    },
    "learning/explain": {
      name: "ai-explain",
      description: "Feynman-style code explanation",
    },
    "sdlc/plan": {
      name: "ai-plan",
      description: "Implementation planning workflow",
    },
  };

  for (const [key, content] of ir.skillSections) {
    const mapping = skillMap[key];
    if (mapping) {
      commands.set(mapping.name, content);
    }
  }

  return commands;
}

function buildClaudeMd(ir: IntermediateRepresentation): string {
  const sections: string[] = [];

  // Header
  sections.push("# Project Standards — ai-engineering");
  sections.push("");
  sections.push(
    `> Generated by ai-engineering v${ir.config.version} on ${new Date().toISOString().split("T")[0]}`,
  );
  sections.push(`> Stacks: ${ir.config.stacks.join(", ")}`);
  sections.push("");

  // Danger zone
  sections.push("## DANGER ZONE — Absolute Rules");
  sections.push("");
  sections.push(
    "These rules are NON-NEGOTIABLE. Violation will be blocked by runtime hooks and git hooks.",
  );
  sections.push("");
  sections.push(
    "- **NEVER** use `git push --force` or `git push -f` to any branch",
  );
  sections.push(
    `- **NEVER** commit directly to protected branches: ${ir.config.branches.protectedBranches.join(", ")}`,
  );
  sections.push(
    "- **NEVER** commit files matching: `.env*`, `*.pem`, `*.key`, `credentials*`, `*secret*`",
  );
  sections.push("- **NEVER** use `--no-verify` flag on any git command");
  sections.push("- **NEVER** hardcode secrets, tokens, passwords, or API keys");
  sections.push(
    "- **NEVER** use `rm -rf` on project root, `.git/`, or `node_modules/` without explicit user request",
  );
  sections.push("- **NEVER** disable TypeScript strict mode or ESLint rules");
  sections.push("- **ALWAYS** run tests after code changes");
  sections.push("- **ALWAYS** use conventional commit format");
  sections.push("");

  // Compliance branches
  sections.push("## Compliance Branches");
  sections.push("");
  sections.push(
    `- **${ir.config.branches.defaultBranch}**: Production. No direct pushes. Requires PR + review + all checks.`,
  );
  sections.push(
    `- **${ir.config.branches.developBranch}**: Integration. Requires PR + checks.`,
  );
  sections.push(
    "- **release/\\***: Release prep. PR to default branch required.",
  );
  sections.push(
    "- **hotfix/\\***: Emergency fixes. Push allowed, must PR to default + develop.",
  );
  sections.push("- **dev/\\***: Feature branches. No restrictions.");
  sections.push("");

  // Standards
  sections.push(ir.assembled.standards);
  sections.push("");

  // Security
  sections.push("## Security Standards");
  sections.push("");
  sections.push(ir.assembled.security);
  sections.push("");

  // Git conventions
  sections.push("## Git Conventions");
  sections.push("");
  sections.push(ir.assembled.git);
  sections.push("");

  // Testing
  sections.push("## Testing Standards");
  sections.push("");
  sections.push(ir.assembled.testing);
  sections.push("");

  // Agents
  sections.push(ir.assembled.agents);
  sections.push("");

  // Skills
  sections.push(ir.assembled.skills);
  sections.push("");

  // Shared utilities
  if (ir.assembled.utils) {
    sections.push(ir.assembled.utils);
    sections.push("");
  }

  // Available commands
  sections.push("## Available Commands");
  sections.push("");
  sections.push("Use these slash commands for guided workflows:");
  sections.push("");
  sections.push("| Command | Description |");
  sections.push("|---------|-------------|");
  sections.push(
    "| `/ai-ship` | Commit + push (default), `pr` for PR, `pr-only` for PR without commit |",
  );
  sections.push("| `/ai-implement` | Guided implementation workflow |");
  sections.push("| `/ai-review` | Structured code review |");
  sections.push("| `/ai-security` | Security audit |");
  sections.push("| `/ai-git` | Git Way-of-Working (cleanup, health, full) |");
  sections.push("| `/ai-explain` | Feynman-style code explanation |");
  sections.push("| `/ai-plan` | Implementation planning workflow |");
  sections.push("");

  // Knowledge
  sections.push("## Project Knowledge");
  sections.push("");
  sections.push(
    "The `.ai-engineering/knowledge/` directory contains project-specific knowledge:",
  );
  sections.push("- `learnings.md` — Lessons learned during development");
  sections.push("- `patterns.md` — Project-specific patterns and conventions");
  sections.push(
    "- `anti-patterns.md` — Known mistakes to avoid in this project",
  );
  sections.push("- `decisions/` — Architecture Decision Records (ADRs)");
  sections.push("");
  sections.push(
    "Read these files at the start of each session to understand project context.",
  );
  sections.push("");

  // Multi-IDE Sync
  sections.push("## Multi-IDE Sync");
  sections.push("");
  sections.push(
    "This project uses ai-engineering with section markers. If you modify the TEAM section",
  );
  sections.push(
    "of this file, check if other IDE instruction files exist and update their TEAM sections",
  );
  sections.push("to keep them in sync:");
  sections.push("- `.github/copilot-instructions.md`");
  sections.push("- `codex.md`");

  return sections.join("\n");
}

export function compileClaudeCode(
  ir: IntermediateRepresentation,
  _projectRoot: string,
): ClaudeCodeOutput {
  logger.info("Compiling Claude Code target...");

  const claudeMd = buildClaudeMd(ir);
  const commands = buildCommands(ir);
  const settingsJson = buildSettingsJson(ir.config);

  return { claudeMd, commands, settingsJson };
}

export function writeClaudeCodeOutput(
  output: ClaudeCodeOutput,
  projectRoot: string,
): void {
  // Write commands
  const commandsDir = resolvePath(projectRoot, ".claude/commands");
  ensureDir(commandsDir);

  // Clean up stale command files before writing new ones
  const expectedFiles = new Set(
    Array.from(output.commands.keys()).map((name) => `${name}.md`),
  );
  for (const existingFile of listFiles(commandsDir)) {
    const fileName = existingFile.split("/").pop() ?? "";
    if (fileName.endsWith(".md") && !expectedFiles.has(fileName)) {
      rmSync(existingFile);
      logger.info(`Removed stale command: ${fileName}`);
    }
  }

  for (const [name, content] of output.commands) {
    writeFile(resolvePath(commandsDir, `${name}.md`), content);
  }
  logger.success(
    `Generated ${output.commands.size} slash commands in .claude/commands/`,
  );

  // Write settings.json
  const settingsPath = resolvePath(projectRoot, ".claude/settings.json");
  writeFile(settingsPath, output.settingsJson);
  logger.success("Generated .claude/settings.json");
}
