import { writeFile, resolvePath } from '../../utils/filesystem.js';
import { logger } from '../../utils/logger.js';
import type { IntermediateRepresentation } from '../assembler.js';

interface CodexOutput {
  codexMd: string;
}

function buildCodexMd(ir: IntermediateRepresentation): string {
  const sections: string[] = [];

  sections.push('# Codex Instructions');
  sections.push('');
  sections.push(`> Generated by ai-engineering v${ir.config.version} on ${new Date().toISOString().split('T')[0]}`);
  sections.push(`> Stacks: ${ir.config.stacks.join(', ')} | Level: ${ir.config.level}`);
  sections.push('');

  // Critical rules
  sections.push('## Absolute Rules');
  sections.push('');
  sections.push('These rules must never be violated:');
  sections.push('');
  sections.push('- Never use `git push --force` or `git push -f`');
  sections.push(`- Never commit directly to: ${ir.config.branches.protectedBranches.join(', ')}`);
  sections.push('- Never commit secrets, credentials, or sensitive files (`.env*`, `*.pem`, `*.key`)');
  sections.push('- Never use `--no-verify` on git commands');
  sections.push('- Never hardcode secrets, tokens, or passwords');
  sections.push('- Always use conventional commits: `<type>(<scope>): <description>`');
  sections.push('- Always verify changes with tests, lint, and typecheck');
  sections.push('');

  // Branch model
  sections.push('## Branch Model');
  sections.push('');
  sections.push(`- Default: \`${ir.config.branches.defaultBranch}\` (protected)`);
  sections.push(`- Integration: \`${ir.config.branches.developBranch}\` (protected)`);
  sections.push('- Features: `feature/*` or `dev/*`');
  sections.push('- Fixes: `fix/*`');
  sections.push('- Hotfixes: `hotfix/*` (can push, must PR to default + develop)');
  sections.push('');

  // Standards
  sections.push(ir.assembled.standards);
  sections.push('');

  // Security
  sections.push('## Security');
  sections.push('');
  sections.push(ir.assembled.security);
  sections.push('');

  // Git
  sections.push('## Git Conventions');
  sections.push('');
  sections.push(ir.assembled.git);
  sections.push('');

  // Testing
  sections.push('## Testing');
  sections.push('');
  sections.push(ir.assembled.testing);
  sections.push('');

  // Workflow guidelines
  sections.push('## Implementation Workflow');
  sections.push('');
  sections.push('1. Read existing code before modifying');
  sections.push('2. Search codebase for existing patterns');
  sections.push('3. Plan approach before implementing');
  sections.push('4. Implement in small, verifiable iterations');
  sections.push('5. Write/update tests for all changes');
  sections.push('6. Verify: build, lint, typecheck, test');
  sections.push('7. Review for unnecessary complexity');
  sections.push('');

  sections.push('## Review Checklist');
  sections.push('');
  sections.push('- [ ] No security vulnerabilities (OWASP top 10)');
  sections.push('- [ ] No hardcoded secrets');
  sections.push('- [ ] Error handling for all failure paths');
  sections.push('- [ ] Tests cover new/changed code');
  sections.push('- [ ] Follows project patterns and conventions');
  sections.push('- [ ] No unnecessary complexity');

  return sections.join('\n');
}

export function compileCodex(ir: IntermediateRepresentation): CodexOutput {
  logger.info('Compiling Codex target...');
  const codexMd = buildCodexMd(ir);
  return { codexMd };
}

export function writeCodexOutput(output: CodexOutput, projectRoot: string): void {
  writeFile(resolvePath(projectRoot, 'codex.md'), output.codexMd);
  logger.success('Generated codex.md');
}
