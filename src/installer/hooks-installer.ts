import {
  writeFile,
  resolvePath,
  fileExists,
  readFile,
} from "../utils/filesystem.js";
import { logger } from "../utils/logger.js";
import { exec } from "../utils/git.js";
import { getPackageRoot } from "../utils/package-root.js";
import type { Config } from "../utils/config.js";

function installRuntimeHooks(projectRoot: string, _config: Config): void {
  const hooksDir = resolvePath(projectRoot, ".ai-engineering/hooks");
  const hookFiles = [
    "pre-tool.sh",
    "post-tool.sh",
    "blocklist.sh",
    "version-check.sh",
  ];

  for (const hookFile of hookFiles) {
    const sourcePath = resolvePath(
      getPackageRoot(),
      "src/hooks/runtime",
      hookFile,
    );
    const destPath = resolvePath(hooksDir, hookFile);

    if (fileExists(sourcePath)) {
      const content = readFile(sourcePath);
      writeFile(destPath, content);
    } else {
      logger.warn(`Hook source not found: ${sourcePath}`);
    }
  }

  // Make hooks executable
  exec(`chmod +x ${hooksDir}/*.sh`);
  logger.success("Installed runtime hooks to .ai-engineering/hooks/");
}

function generateLefthookConfig(config: Config): string {
  const sections: string[] = [
    "# Generated by ai-engineering â€” Git hooks via Lefthook",
    "",
  ];

  // Pre-commit hooks
  sections.push("pre-commit:");
  sections.push("  parallel: true");
  sections.push("  commands:");

  sections.push("    gitleaks:");
  sections.push("      run: gitleaks protect --staged --no-banner");

  // Stack-specific linters
  if (config.stacks.includes("typescript-react")) {
    sections.push("    eslint:");
    sections.push('      glob: "*.{ts,tsx,js,jsx}"');
    sections.push("      run: npx eslint {staged_files}");
    sections.push("    prettier:");
    sections.push('      glob: "*.{ts,tsx,js,jsx,json,md,yml,yaml,css,scss}"');
    sections.push("      run: npx prettier --check {staged_files}");
  }

  if (config.stacks.includes("python")) {
    sections.push("    ruff:");
    sections.push('      glob: "*.py"');
    sections.push("      run: ruff check {staged_files}");
    sections.push("    black:");
    sections.push('      glob: "*.py"');
    sections.push("      run: black --check {staged_files}");
  }

  if (config.stacks.includes("dotnet")) {
    sections.push("    dotnet-format:");
    sections.push('      glob: "*.cs"');
    sections.push("      run: dotnet format --verify-no-changes");
  }

  sections.push("");

  // Commit-msg hook
  sections.push("commit-msg:");
  sections.push("  commands:");
  sections.push("    conventional:");
  sections.push("      run: |");
  sections.push("        MSG=$(cat {1})");
  sections.push(
    '        if echo "$MSG" | grep -qE "^Merge |^Revert "; then exit 0; fi',
  );
  sections.push(
    "        if ! echo \"$MSG\" | head -1 | grep -qE '^(feat|fix|docs|style|refactor|perf|test|build|ci|chore|revert)(\\([a-zA-Z0-9_-]+\\))?: .{1,}'; then",
  );
  sections.push(
    '          echo "Commit message must follow Conventional Commits: <type>(<scope>): <description>"',
  );
  sections.push("          exit 1");
  sections.push("        fi");
  sections.push("");

  // Pre-push hooks
  const defaultBranch = config.branches.defaultBranch;
  sections.push("pre-push:");
  sections.push("  parallel: true");
  sections.push("  commands:");
  sections.push("    branch-protection:");
  sections.push(`      run: |`);
  sections.push(`        BRANCH=$(git branch --show-current)`);
  for (const branch of config.branches.protectedBranches) {
    sections.push(
      `        if [ "$BRANCH" = "${branch}" ]; then echo "Direct push to ${branch} blocked. Use a PR."; exit 1; fi`,
    );
  }

  if (config.stacks.includes("typescript-react")) {
    sections.push("    lint:");
    sections.push("      run: npx eslint .");
    sections.push("    typecheck:");
    sections.push("      run: npx tsc --noEmit");
    sections.push("    test:");
    sections.push("      run: npm test");
    sections.push("    build:");
    sections.push("      run: npm run build");
    sections.push("    npm-audit:");
    sections.push("      run: npm audit --audit-level=high");
  }

  if (config.stacks.includes("python")) {
    sections.push("    lint:");
    sections.push("      run: ruff check .");
    sections.push("    pytest:");
    sections.push("      run: pytest --quiet");
    sections.push("    pip-audit:");
    sections.push("      run: pip-audit");
  }

  if (config.stacks.includes("dotnet")) {
    sections.push("    dotnet-lint:");
    sections.push("      run: dotnet format --verify-no-changes");
    sections.push("    dotnet-build:");
    sections.push("      run: dotnet build --no-restore");
    sections.push("    dotnet-test:");
    sections.push("      run: dotnet test --verbosity quiet");
  }

  sections.push("    gitleaks-branch:");
  sections.push(
    `      run: gitleaks detect --source . --log-opts "$(git merge-base HEAD origin/${defaultBranch})..HEAD" --no-banner`,
  );
  sections.push("    semgrep:");
  sections.push("      run: semgrep --config=auto --error .");

  return sections.join("\n") + "\n";
}

function installGitHooks(projectRoot: string, config: Config): void {
  // Generate lefthook.yml
  const lefthookConfig = generateLefthookConfig(config);
  writeFile(resolvePath(projectRoot, "lefthook.yml"), lefthookConfig);
  logger.success("Generated lefthook.yml");

  // Install gitleaks config
  const gitleaksConfig = `title = "ai-engineering gitleaks config"

[extend]
useDefault = true

[allowlist]
description = "Global allow list"
paths = [
  '''node_modules''',
  '''dist''',
  '''\\.git''',
  '''pnpm-lock\\.yaml''',
  '''package-lock\\.json''',
  '''test/fixtures''',
]
`;
  writeFile(resolvePath(projectRoot, ".gitleaks.toml"), gitleaksConfig);
  logger.success("Generated .gitleaks.toml");

  // Try to install lefthook hooks
  const lefthookVersion = exec("lefthook version");
  if (lefthookVersion) {
    exec(`lefthook install`, projectRoot);
    logger.success("Lefthook hooks installed");
  } else {
    logger.warn(
      "Lefthook not found. Install it to activate git hooks: npm i -D @evilmartians/lefthook",
    );
  }
}

export function installHooks(projectRoot: string, config: Config): void {
  logger.step(3, 4, "Installing hooks...");
  installRuntimeHooks(projectRoot, config);
  installGitHooks(projectRoot, config);
}
