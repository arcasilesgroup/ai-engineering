import { writeFile, resolvePath, fileExists, readFile } from '../utils/filesystem.js';
import { logger } from '../utils/logger.js';
import { exec } from '../utils/git.js';
import type { Config } from '../utils/config.js';

function resolveHookSource(relativePath: string): string {
  const devPath = resolvePath(import.meta.dirname ?? '.', '../../', relativePath);
  if (fileExists(devPath)) return devPath;

  const distPath = resolvePath(import.meta.dirname ?? '.', '../', relativePath);
  if (fileExists(distPath)) return distPath;

  return devPath;
}

function installRuntimeHooks(projectRoot: string, config: Config): void {
  if (config.level === 'basic') {
    logger.debug('Skipping runtime hooks for basic level');
    return;
  }

  const hooksDir = resolvePath(projectRoot, '.ai-engineering/hooks');
  const hookFiles = ['pre-tool.sh', 'post-tool.sh', 'blocklist.sh', 'version-check.sh'];

  for (const hookFile of hookFiles) {
    const sourcePath = resolveHookSource(`src/hooks/runtime/${hookFile}`);
    const destPath = resolvePath(hooksDir, hookFile);

    if (fileExists(sourcePath)) {
      const content = readFile(sourcePath);
      writeFile(destPath, content);
    } else {
      logger.warn(`Hook source not found: ${sourcePath}`);
    }
  }

  // Make hooks executable
  exec(`chmod +x ${hooksDir}/*.sh`);
  logger.success('Installed runtime hooks to .ai-engineering/hooks/');
}

function generateLefthookConfig(config: Config): string {
  const sections: string[] = [
    '# Generated by ai-engineering â€” Git hooks via Lefthook',
    `# Enforcement level: ${config.level}`,
    '',
  ];

  // Pre-commit hooks
  sections.push('pre-commit:');
  sections.push('  parallel: true');
  sections.push('  commands:');

  sections.push('    gitleaks:');
  sections.push('      run: gitleaks protect --staged --no-banner');

  // Stack-specific linters
  if (config.stacks.includes('typescript-react')) {
    sections.push('    eslint:');
    sections.push('      glob: "*.{ts,tsx,js,jsx}"');
    sections.push('      run: npx eslint {staged_files}');
    sections.push('    prettier:');
    sections.push('      glob: "*.{ts,tsx,js,jsx,json,md,yml,yaml,css,scss}"');
    sections.push('      run: npx prettier --check {staged_files}');
  }

  if (config.stacks.includes('python')) {
    sections.push('    ruff:');
    sections.push('      glob: "*.py"');
    sections.push('      run: ruff check {staged_files}');
    sections.push('    black:');
    sections.push('      glob: "*.py"');
    sections.push('      run: black --check {staged_files}');
  }

  if (config.stacks.includes('dotnet')) {
    sections.push('    dotnet-format:');
    sections.push('      glob: "*.cs"');
    sections.push('      run: dotnet format --verify-no-changes');
  }

  sections.push('');

  // Commit-msg hook
  sections.push('commit-msg:');
  sections.push('  commands:');
  sections.push('    conventional:');
  sections.push('      run: |');
  sections.push('        MSG=$(cat {1})');
  sections.push('        if echo "$MSG" | grep -qE "^Merge |^Revert "; then exit 0; fi');
  sections.push("        if ! echo \"$MSG\" | head -1 | grep -qE '^(feat|fix|docs|style|refactor|perf|test|build|ci|chore|revert)(\\([a-zA-Z0-9_-]+\\))?: .{1,}'; then");
  sections.push('          echo "Commit message must follow Conventional Commits: <type>(<scope>): <description>"');
  sections.push('          exit 1');
  sections.push('        fi');
  sections.push('');

  // Pre-push hooks (standard and strict only)
  if (config.level !== 'basic') {
    sections.push('pre-push:');
    sections.push('  parallel: true');
    sections.push('  commands:');
    sections.push('    branch-protection:');
    sections.push(`      run: |`);
    sections.push(`        BRANCH=$(git branch --show-current)`);
    for (const branch of config.branches.protectedBranches) {
      sections.push(`        if [ "$BRANCH" = "${branch}" ]; then echo "Direct push to ${branch} blocked. Use a PR."; exit 1; fi`);
    }

    if (config.stacks.includes('typescript-react')) {
      sections.push('    test:');
      sections.push('      run: npm test');
      sections.push('    typecheck:');
      sections.push('      run: npx tsc --noEmit');
    }

    if (config.stacks.includes('python')) {
      sections.push('    pytest:');
      sections.push('      run: pytest --quiet');
    }

    if (config.stacks.includes('dotnet')) {
      sections.push('    dotnet-test:');
      sections.push('      run: dotnet test --verbosity quiet');
    }

    // Dependency audit (strict only)
    if (config.level === 'strict') {
      if (config.stacks.includes('typescript-react')) {
        sections.push('    npm-audit:');
        sections.push('      run: npm audit --audit-level=high');
      }
      if (config.stacks.includes('python')) {
        sections.push('    pip-audit:');
        sections.push('      run: pip-audit');
      }
    }
  }

  return sections.join('\n') + '\n';
}

function installGitHooks(projectRoot: string, config: Config): void {
  if (config.level === 'basic') {
    logger.debug('Skipping git hooks for basic level');
    return;
  }

  // Generate lefthook.yml
  const lefthookConfig = generateLefthookConfig(config);
  writeFile(resolvePath(projectRoot, 'lefthook.yml'), lefthookConfig);
  logger.success('Generated lefthook.yml');

  // Install gitleaks config
  const gitleaksConfig = `title = "ai-engineering gitleaks config"

[extend]
useDefault = true

[allowlist]
description = "Global allow list"
paths = [
  '''node_modules''',
  '''dist''',
  '''\\.git''',
  '''pnpm-lock\\.yaml''',
  '''package-lock\\.json''',
  '''test/fixtures''',
]
`;
  writeFile(resolvePath(projectRoot, '.gitleaks.toml'), gitleaksConfig);
  logger.success('Generated .gitleaks.toml');

  // Try to install lefthook hooks
  const lefthookVersion = exec('lefthook version');
  if (lefthookVersion) {
    exec(`lefthook install`, projectRoot);
    logger.success('Lefthook hooks installed');
  } else {
    logger.warn('Lefthook not found. Install it to activate git hooks: npm i -D @evilmartians/lefthook');
  }
}

export function installHooks(projectRoot: string, config: Config): void {
  logger.step(3, 4, 'Installing hooks...');
  installRuntimeHooks(projectRoot, config);
  installGitHooks(projectRoot, config);
}
