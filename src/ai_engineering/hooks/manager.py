"""Git hook generation and installation for ai-engineering.

Provides:
- Cross-OS hook script generation (Bash + PowerShell dispatcher).
- Installation into ``.git/hooks/`` with create-only semantics.
- Conflict detection for third-party hook managers (husky, lefthook, pre-commit).
- Hook integrity verification.
"""

from __future__ import annotations

import stat
from dataclasses import dataclass, field
from pathlib import Path

from ai_engineering.state.models import GateHook

# Third-party hook managers that may conflict with our hooks.
_KNOWN_HOOK_MANAGERS: dict[str, list[str]] = {
    "husky": [".husky"],
    "lefthook": ["lefthook.yml", "lefthook.yaml", ".lefthook.yml", ".lefthook.yaml"],
    "pre-commit": [".pre-commit-config.yaml", ".pre-commit-config.yml"],
}

# Marker line embedded in generated hooks so we can identify our own scripts.
_HOOK_MARKER: str = "# ai-engineering-managed-hook"

# Gate commands per hook type.  These are the CLI commands that each hook
# invokes.  The actual check logic lives in ``policy.gates``.
_GATE_COMMANDS: dict[GateHook, str] = {
    GateHook.PRE_COMMIT: "ai-eng gate pre-commit",
    GateHook.COMMIT_MSG: "ai-eng gate commit-msg",
    GateHook.PRE_PUSH: "ai-eng gate pre-push",
}


@dataclass
class HookConflict:
    """Describes a detected third-party hook manager."""

    manager: str
    indicator: str


@dataclass
class HookInstallResult:
    """Summary of a hook installation operation."""

    installed: list[str] = field(default_factory=list)
    skipped: list[str] = field(default_factory=list)
    conflicts: list[HookConflict] = field(default_factory=list)


def generate_bash_hook(hook: GateHook) -> str:
    """Generate a Bash hook script for the given gate.

    The script invokes ``ai-eng gate <hook-type>`` and forwards
    stdin (used by commit-msg for the message file path) and
    ``$@`` for any arguments.

    Args:
        hook: The gate hook type to generate.

    Returns:
        Complete Bash script content.
    """
    command = _GATE_COMMANDS[hook]
    return f"""\
#!/usr/bin/env bash
{_HOOK_MARKER}
# Auto-generated by ai-engineering. Do not edit manually.
set -euo pipefail

{command} "$@"
"""


def generate_powershell_hook(hook: GateHook) -> str:
    """Generate a PowerShell hook script for the given gate.

    Args:
        hook: The gate hook type to generate.

    Returns:
        Complete PowerShell script content.
    """
    command = _GATE_COMMANDS[hook]
    return f"""\
{_HOOK_MARKER}
# Auto-generated by ai-engineering. Do not edit manually.
$ErrorActionPreference = 'Stop'

{command} $args
if ($LASTEXITCODE -ne 0) {{ exit $LASTEXITCODE }}
"""


def generate_dispatcher_hook(hook: GateHook) -> str:
    """Generate a cross-OS dispatcher hook script.

    Git on Windows uses Git Bash to execute hooks, so a Bash script
    works as the dispatcher.  The script detects the OS and delegates
    to the appropriate implementation.

    For simplicity and maximum compatibility, we generate a single Bash
    script that works on all platforms (Git for Windows ships with Bash).

    Args:
        hook: The gate hook type to generate.

    Returns:
        Complete dispatcher script (Bash).
    """
    return generate_bash_hook(hook)


def detect_conflicts(project_root: Path) -> list[HookConflict]:
    """Detect third-party hook managers that may conflict.

    Searches the project root for configuration files and directories
    associated with husky, lefthook, and pre-commit.

    Args:
        project_root: Root directory of the target project.

    Returns:
        List of detected conflicts (empty if none found).
    """
    conflicts: list[HookConflict] = []
    for manager, indicators in _KNOWN_HOOK_MANAGERS.items():
        for indicator in indicators:
            candidate = project_root / indicator
            if candidate.exists():
                conflicts.append(HookConflict(manager=manager, indicator=indicator))
    return conflicts


def is_managed_hook(hook_path: Path) -> bool:
    """Check if a hook file was generated by ai-engineering.

    Args:
        hook_path: Path to the hook file.

    Returns:
        True if the hook contains the ai-engineering marker.
    """
    if not hook_path.is_file():
        return False
    try:
        content = hook_path.read_text(encoding="utf-8")
    except (OSError, UnicodeDecodeError):
        return False
    return _HOOK_MARKER in content


def install_hooks(
    project_root: Path,
    *,
    hooks: list[GateHook] | None = None,
    force: bool = False,
) -> HookInstallResult:
    """Install git hook scripts into ``.git/hooks/``.

    By default, installs all three gate hooks (pre-commit, commit-msg,
    pre-push).  Uses create-only semantics: existing hooks that were NOT
    generated by ai-engineering are never overwritten unless ``force=True``.

    Args:
        project_root: Root directory of the git repository.
        hooks: Specific hooks to install. Defaults to all gate hooks.
        force: If True, overwrite existing non-managed hooks.

    Returns:
        HookInstallResult with installed, skipped, and conflict details.

    Raises:
        FileNotFoundError: If ``.git/hooks/`` directory does not exist.
    """
    hooks_dir = project_root / ".git" / "hooks"
    if not hooks_dir.is_dir():
        msg = f"Git hooks directory not found: {hooks_dir}. Is this a git repository?"
        raise FileNotFoundError(msg)

    target_hooks = hooks or list(GateHook)
    result = HookInstallResult()
    result.conflicts = detect_conflicts(project_root)

    for hook in target_hooks:
        hook_path = hooks_dir / hook.value
        ps_path = hooks_dir / f"{hook.value}.ps1"

        if hook_path.exists() and not is_managed_hook(hook_path) and not force:
            result.skipped.append(hook.value)
            continue

        # Write Bash dispatcher (primary)
        content = generate_dispatcher_hook(hook)
        hook_path.write_text(content, encoding="utf-8")
        _make_executable(hook_path)

        # Write PowerShell companion
        ps_content = generate_powershell_hook(hook)
        ps_path.write_text(ps_content, encoding="utf-8")

        result.installed.append(hook.value)

    return result


def uninstall_hooks(
    project_root: Path,
    *,
    hooks: list[GateHook] | None = None,
) -> list[str]:
    """Remove ai-engineering-managed hooks from ``.git/hooks/``.

    Only removes hooks that contain the ai-engineering marker.
    Third-party or user-created hooks are left untouched.

    Args:
        project_root: Root directory of the git repository.
        hooks: Specific hooks to remove. Defaults to all gate hooks.

    Returns:
        List of hook names that were removed.
    """
    hooks_dir = project_root / ".git" / "hooks"
    if not hooks_dir.is_dir():
        return []

    target_hooks = hooks or list(GateHook)
    removed: list[str] = []

    for hook in target_hooks:
        hook_path = hooks_dir / hook.value
        ps_path = hooks_dir / f"{hook.value}.ps1"

        if is_managed_hook(hook_path):
            hook_path.unlink()
            removed.append(hook.value)

        if ps_path.is_file():
            ps_path.unlink()

    return removed


def verify_hooks(project_root: Path) -> dict[str, bool]:
    """Verify that all required hooks are installed and managed.

    Args:
        project_root: Root directory of the git repository.

    Returns:
        Dict mapping hook name to verification status (True = valid).
    """
    hooks_dir = project_root / ".git" / "hooks"
    status: dict[str, bool] = {}

    for hook in GateHook:
        hook_path = hooks_dir / hook.value
        status[hook.value] = is_managed_hook(hook_path)

    return status


def _make_executable(path: Path) -> None:
    """Add executable permission bits to a file (Unix-like systems).

    On Windows this is a no-op since file permissions work differently,
    but Git for Windows respects the executable bit in the index.

    Args:
        path: Path to the file to make executable.
    """
    try:
        current = path.stat().st_mode
        path.chmod(current | stat.S_IXUSR | stat.S_IXGRP | stat.S_IXOTH)
    except OSError:
        pass  # Windows or permission-restricted environment
