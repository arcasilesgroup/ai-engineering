"""Tests for commands/workflows â€” commit, PR, and PR-only flows.

Covers:
- Branch protection blocking on main/master.
- Commit workflow step sequence (stage, format, lint, gitleaks, commit, push).
- Commit --only skipping push.
- PR workflow with pre-push checks and auto-complete.
- PR --only workflow with unpushed branch handling.
- Audit log entries generated by workflow events.
- Decision store integration for unpushed branch decisions.
"""

from __future__ import annotations

import json
from pathlib import Path
from unittest.mock import MagicMock, patch

import pytest

from ai_engineering.commands.workflows import (
    StepResult,
    WorkflowResult,
    run_commit_workflow,
    run_pr_only_workflow,
    run_pr_workflow,
)
from ai_engineering.installer.service import install


# ---------------------------------------------------------------------------
# Fixtures
# ---------------------------------------------------------------------------


@pytest.fixture()
def installed_project(tmp_path: Path) -> Path:
    """Create a fully installed project for testing."""
    install(tmp_path, stacks=["python"], ides=["vscode"])
    return tmp_path


@pytest.fixture()
def git_project(installed_project: Path) -> Path:
    """Installed project with a real git repo on a feature branch."""
    import subprocess

    subprocess.run(
        ["git", "init"],
        cwd=installed_project,
        check=True,
        capture_output=True,
    )
    subprocess.run(
        ["git", "config", "user.email", "test@test.com"],
        cwd=installed_project,
        check=True,
        capture_output=True,
    )
    subprocess.run(
        ["git", "config", "user.name", "Test"],
        cwd=installed_project,
        check=True,
        capture_output=True,
    )
    # Initial commit on main
    subprocess.run(
        ["git", "add", "-A"],
        cwd=installed_project,
        check=True,
        capture_output=True,
    )
    subprocess.run(
        ["git", "commit", "-m", "initial"],
        cwd=installed_project,
        check=True,
        capture_output=True,
    )
    # Switch to feature branch
    subprocess.run(
        ["git", "checkout", "-b", "feature/test"],
        cwd=installed_project,
        check=True,
        capture_output=True,
    )
    return installed_project


# ---------------------------------------------------------------------------
# WorkflowResult
# ---------------------------------------------------------------------------


class TestWorkflowResult:
    """Tests for the WorkflowResult dataclass."""

    def test_passed_when_all_steps_pass(self) -> None:
        result = WorkflowResult(
            workflow="test",
            steps=[
                StepResult(name="a", passed=True),
                StepResult(name="b", passed=True),
            ],
        )
        assert result.passed is True
        assert result.failed_steps == []

    def test_failed_when_any_step_fails(self) -> None:
        result = WorkflowResult(
            workflow="test",
            steps=[
                StepResult(name="a", passed=True),
                StepResult(name="b", passed=False),
            ],
        )
        assert result.passed is False
        assert result.failed_steps == ["b"]

    def test_skipped_steps_dont_fail(self) -> None:
        result = WorkflowResult(
            workflow="test",
            steps=[
                StepResult(name="a", passed=True),
                StepResult(name="b", passed=False, skipped=True),
            ],
        )
        assert result.passed is True

    def test_empty_steps_pass(self) -> None:
        result = WorkflowResult(workflow="test")
        assert result.passed is True


# ---------------------------------------------------------------------------
# Branch protection
# ---------------------------------------------------------------------------


class TestBranchProtection:
    """Tests for protected branch blocking in workflows."""

    def test_commit_blocked_on_main(self, git_project: Path) -> None:
        with patch(
            "ai_engineering.commands.workflows._current_branch",
            return_value="main",
        ):
            result = run_commit_workflow(git_project, "test commit")
        assert result.passed is False
        assert "branch-protection" in result.failed_steps

    def test_commit_blocked_on_master(self, git_project: Path) -> None:
        with patch(
            "ai_engineering.commands.workflows._current_branch",
            return_value="master",
        ):
            result = run_commit_workflow(git_project, "test commit")
        assert result.passed is False

    def test_commit_allowed_on_feature(self, git_project: Path) -> None:
        # Mock all external commands to succeed
        with patch(
            "ai_engineering.commands.workflows._run_command",
            return_value=(True, "ok"),
        ):
            result = run_commit_workflow(git_project, "test commit")
        assert result.steps[0].name == "branch-protection"
        assert result.steps[0].passed is True


# ---------------------------------------------------------------------------
# Commit workflow
# ---------------------------------------------------------------------------


class TestCommitWorkflow:
    """Tests for run_commit_workflow."""

    def test_all_steps_executed_on_success(
        self, git_project: Path,
    ) -> None:
        with patch(
            "ai_engineering.commands.workflows._run_command",
            return_value=(True, "ok"),
        ):
            result = run_commit_workflow(git_project, "feat: test")

        step_names = [s.name for s in result.steps]
        assert "branch-protection" in step_names
        assert "stage" in step_names
        assert "format" in step_names
        assert "lint" in step_names
        assert "gitleaks" in step_names
        assert "commit" in step_names
        assert "push" in step_names
        assert result.passed is True

    def test_only_mode_skips_push(self, git_project: Path) -> None:
        with patch(
            "ai_engineering.commands.workflows._run_command",
            return_value=(True, "ok"),
        ):
            result = run_commit_workflow(
                git_project, "feat: test", push=False,
            )

        push_step = next(s for s in result.steps if s.name == "push")
        assert push_step.skipped is True
        assert result.passed is True

    def test_lint_failure_stops_workflow(
        self, git_project: Path,
    ) -> None:
        call_count = 0

        def mock_run(cmd: list[str], cwd: Path, **kwargs: object) -> tuple[bool, str]:
            nonlocal call_count
            call_count += 1
            # Fail on lint (3rd _run_command call: stage, format, lint)
            if call_count == 3:
                return False, "lint error: E501"
            return True, "ok"

        with patch(
            "ai_engineering.commands.workflows._run_command",
            side_effect=mock_run,
        ):
            result = run_commit_workflow(git_project, "feat: test")

        assert result.passed is False
        assert "lint" in result.failed_steps
        # Should not have commit or push steps
        step_names = [s.name for s in result.steps]
        assert "commit" not in step_names

    def test_gitleaks_failure_stops_workflow(
        self, git_project: Path,
    ) -> None:
        call_count = 0

        def mock_run(cmd: list[str], cwd: Path, **kwargs: object) -> tuple[bool, str]:
            nonlocal call_count
            call_count += 1
            # Fail on gitleaks (4th call: stage, format, lint, gitleaks)
            if call_count == 4:
                return False, "secret found"
            return True, "ok"

        with patch(
            "ai_engineering.commands.workflows._run_command",
            side_effect=mock_run,
        ):
            result = run_commit_workflow(git_project, "feat: test")

        assert result.passed is False
        assert "gitleaks" in result.failed_steps


# ---------------------------------------------------------------------------
# PR workflow
# ---------------------------------------------------------------------------


class TestPRWorkflow:
    """Tests for run_pr_workflow."""

    def test_pr_workflow_includes_pre_push_checks(
        self, git_project: Path,
    ) -> None:
        with patch(
            "ai_engineering.commands.workflows._run_command",
            return_value=(True, "ok"),
        ):
            result = run_pr_workflow(git_project, "feat: pr test")

        step_names = [s.name for s in result.steps]
        assert "semgrep" in step_names
        assert "pip-audit" in step_names
        assert "pytest" in step_names
        assert "ty" in step_names
        assert "create-pr" in step_names
        assert "auto-complete" in step_names
        assert result.passed is True

    def test_pr_workflow_stops_on_commit_failure(
        self, git_project: Path,
    ) -> None:
        with patch(
            "ai_engineering.commands.workflows._current_branch",
            return_value="main",
        ):
            result = run_pr_workflow(git_project, "feat: test")

        assert result.passed is False
        step_names = [s.name for s in result.steps]
        assert "create-pr" not in step_names


class TestPROnlyWorkflow:
    """Tests for run_pr_only_workflow."""

    def test_pr_only_creates_pr(self, git_project: Path) -> None:
        with patch(
            "ai_engineering.commands.workflows._run_command",
            return_value=(True, "ok"),
        ), patch(
            "ai_engineering.commands.workflows._is_branch_pushed",
            return_value=True,
        ):
            result = run_pr_only_workflow(git_project)

        step_names = [s.name for s in result.steps]
        assert "create-pr" in step_names
        assert "auto-complete" in step_names
        assert result.passed is True

    def test_pr_only_auto_pushes_unpushed_branch(
        self, git_project: Path,
    ) -> None:
        with patch(
            "ai_engineering.commands.workflows._run_command",
            return_value=(True, "ok"),
        ), patch(
            "ai_engineering.commands.workflows._is_branch_pushed",
            return_value=False,
        ), patch(
            "ai_engineering.commands.workflows._check_unpushed_decision",
            return_value=None,
        ):
            result = run_pr_only_workflow(git_project)

        step_names = [s.name for s in result.steps]
        assert "auto-push" in step_names
        assert result.passed is True

    def test_pr_only_defers_on_prior_decision(
        self, git_project: Path,
    ) -> None:
        with patch(
            "ai_engineering.commands.workflows._is_branch_pushed",
            return_value=False,
        ), patch(
            "ai_engineering.commands.workflows._check_unpushed_decision",
            return_value="defer-pr",
        ):
            result = run_pr_only_workflow(git_project)

        assert result.passed is False
        assert "unpushed-check" in result.failed_steps


# ---------------------------------------------------------------------------
# Audit logging
# ---------------------------------------------------------------------------


class TestAuditLogging:
    """Tests for audit log entries generated by workflows."""

    def test_commit_logs_audit_entry(self, git_project: Path) -> None:
        with patch(
            "ai_engineering.commands.workflows._run_command",
            return_value=(True, "ok"),
        ):
            run_commit_workflow(git_project, "feat: audit test")

        audit_path = (
            git_project / ".ai-engineering" / "state" / "audit-log.ndjson"
        )
        assert audit_path.exists()
        lines = audit_path.read_text(encoding="utf-8").strip().splitlines()
        # Should have install entry + commit entry
        events = [json.loads(line)["event"] for line in lines]
        assert "commit" in events

    def test_branch_block_logs_audit_entry(
        self, git_project: Path,
    ) -> None:
        with patch(
            "ai_engineering.commands.workflows._current_branch",
            return_value="main",
        ):
            run_commit_workflow(git_project, "test")

        audit_path = (
            git_project / ".ai-engineering" / "state" / "audit-log.ndjson"
        )
        lines = audit_path.read_text(encoding="utf-8").strip().splitlines()
        events = [json.loads(line)["event"] for line in lines]
        assert "branch-protection-block" in events
