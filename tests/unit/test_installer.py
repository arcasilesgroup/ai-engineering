"""Tests for installer: templates, service, and operations.

Covers:
- Template discovery and path resolution.
- Create-only copy semantics (never overwrites).
- Full install on empty and existing repos.
- Stack/IDE add/remove/list operations.
- Audit-log entries generated by install and mutations.
"""

from __future__ import annotations

import json
from pathlib import Path

import pytest

from ai_engineering.installer.operations import (
    InstallerError,
    add_ide,
    add_stack,
    list_status,
    remove_ide,
    remove_stack,
)
from ai_engineering.installer.service import InstallResult, install
from ai_engineering.installer.templates import (
    CopyResult,
    copy_file_if_missing,
    copy_project_templates,
    copy_template_tree,
    get_ai_engineering_template_root,
    get_project_template_root,
)
from ai_engineering.state.models import AuditEntry, InstallManifest


# ---------------------------------------------------------------------------
# Templates
# ---------------------------------------------------------------------------


class TestTemplateDiscovery:
    """Tests for template root resolution."""

    def test_ai_engineering_template_root_exists(self) -> None:
        root = get_ai_engineering_template_root()
        assert root.is_dir()
        assert (root / "manifest.yml").is_file()

    def test_project_template_root_exists(self) -> None:
        root = get_project_template_root()
        assert root.is_dir()
        assert (root / "CLAUDE.md").is_file()

    def test_ai_engineering_template_root_missing_raises(
        self, tmp_path: Path, monkeypatch: pytest.MonkeyPatch,
    ) -> None:
        import ai_engineering.installer.templates as tpl_mod

        monkeypatch.setattr(tpl_mod, "TEMPLATES_ROOT", tmp_path / "nonexistent")
        with pytest.raises(FileNotFoundError, match="Template directory"):
            get_ai_engineering_template_root()

    def test_project_template_root_missing_raises(
        self, tmp_path: Path, monkeypatch: pytest.MonkeyPatch,
    ) -> None:
        import ai_engineering.installer.templates as tpl_mod

        monkeypatch.setattr(tpl_mod, "TEMPLATES_ROOT", tmp_path / "nonexistent")
        with pytest.raises(FileNotFoundError, match="Template directory"):
            get_project_template_root()


class TestCopyFileIfMissing:
    """Tests for single-file create-only copy."""

    def test_copies_when_missing(self, tmp_path: Path) -> None:
        src = tmp_path / "src" / "file.txt"
        src.parent.mkdir()
        src.write_text("content")
        dest = tmp_path / "dest" / "file.txt"

        assert copy_file_if_missing(src, dest) is True
        assert dest.read_text() == "content"

    def test_skips_when_existing(self, tmp_path: Path) -> None:
        src = tmp_path / "src" / "file.txt"
        src.parent.mkdir()
        src.write_text("new")
        dest = tmp_path / "dest" / "file.txt"
        dest.parent.mkdir()
        dest.write_text("old")

        assert copy_file_if_missing(src, dest) is False
        assert dest.read_text() == "old"


class TestCopyTemplateTree:
    """Tests for recursive tree copy with create-only semantics."""

    def test_copies_entire_tree(self, tmp_path: Path) -> None:
        src = tmp_path / "src"
        (src / "a").mkdir(parents=True)
        (src / "a" / "1.txt").write_text("a1")
        (src / "b.txt").write_text("b")

        dest = tmp_path / "dest"
        result = copy_template_tree(src, dest)

        assert len(result.created) == 2
        assert len(result.skipped) == 0
        assert (dest / "a" / "1.txt").read_text() == "a1"
        assert (dest / "b.txt").read_text() == "b"

    def test_skips_existing_files(self, tmp_path: Path) -> None:
        src = tmp_path / "src"
        src.mkdir()
        (src / "keep.txt").write_text("new")

        dest = tmp_path / "dest"
        dest.mkdir()
        (dest / "keep.txt").write_text("old")

        result = copy_template_tree(src, dest)

        assert len(result.created) == 0
        assert len(result.skipped) == 1
        assert (dest / "keep.txt").read_text() == "old"

    def test_mixed_new_and_existing(self, tmp_path: Path) -> None:
        src = tmp_path / "src"
        src.mkdir()
        (src / "new.txt").write_text("new")
        (src / "old.txt").write_text("updated")

        dest = tmp_path / "dest"
        dest.mkdir()
        (dest / "old.txt").write_text("original")

        result = copy_template_tree(src, dest)

        assert len(result.created) == 1
        assert len(result.skipped) == 1
        assert (dest / "new.txt").read_text() == "new"
        assert (dest / "old.txt").read_text() == "original"


class TestCopyProjectTemplates:
    """Tests for project template mapping."""

    def test_copies_project_templates_to_correct_locations(
        self, tmp_path: Path,
    ) -> None:
        result = copy_project_templates(tmp_path)

        # CLAUDE.md → project root
        assert (tmp_path / "CLAUDE.md").is_file()
        # copilot-instructions.md → .github/
        assert (tmp_path / ".github" / "copilot-instructions.md").is_file()
        # copilot subdir → .github/copilot/
        assert (tmp_path / ".github" / "copilot" / "code-generation.md").is_file()
        assert len(result.created) >= 4  # at least CLAUDE, codex, copilot-instructions, + copilot/*

    def test_skips_existing_project_files(self, tmp_path: Path) -> None:
        # Pre-create CLAUDE.md
        (tmp_path / "CLAUDE.md").write_text("custom")
        result = copy_project_templates(tmp_path)

        assert (tmp_path / "CLAUDE.md").read_text() == "custom"
        assert any(p.name == "CLAUDE.md" for p in result.skipped)


# ---------------------------------------------------------------------------
# Service — install()
# ---------------------------------------------------------------------------


class TestInstallOnEmptyRepo:
    """Tests for install() on a clean target directory."""

    def test_creates_complete_structure(self, tmp_path: Path) -> None:
        result = install(tmp_path)

        assert isinstance(result, InstallResult)
        assert result.total_created > 0
        assert result.already_installed is False

        # Governance structure created
        assert (tmp_path / ".ai-engineering" / "manifest.yml").is_file()
        assert (tmp_path / ".ai-engineering" / "standards" / "framework" / "core.md").is_file()

        # State files generated
        assert (tmp_path / ".ai-engineering" / "state" / "install-manifest.json").is_file()
        assert (tmp_path / ".ai-engineering" / "state" / "ownership-map.json").is_file()
        assert (tmp_path / ".ai-engineering" / "state" / "decision-store.json").is_file()
        assert (tmp_path / ".ai-engineering" / "state" / "sources.lock.json").is_file()

        # Project files created
        assert (tmp_path / "CLAUDE.md").is_file()
        assert (tmp_path / ".github" / "copilot-instructions.md").is_file()

        # Audit log written
        assert (tmp_path / ".ai-engineering" / "state" / "audit-log.ndjson").is_file()

    def test_state_files_contain_valid_json(self, tmp_path: Path) -> None:
        install(tmp_path)

        manifest_path = tmp_path / ".ai-engineering" / "state" / "install-manifest.json"
        data = json.loads(manifest_path.read_text())
        assert data["schemaVersion"] == "1.1"
        assert "python" in data["installedStacks"]
        assert "terminal" in data["installedIdes"]

    def test_custom_stacks_and_ides(self, tmp_path: Path) -> None:
        install(tmp_path, stacks=["python", "node"], ides=["vscode", "terminal"])

        manifest_path = tmp_path / ".ai-engineering" / "state" / "install-manifest.json"
        data = json.loads(manifest_path.read_text())
        assert data["installedStacks"] == ["python", "node"]
        assert data["installedIdes"] == ["vscode", "terminal"]

    def test_audit_log_records_install_event(self, tmp_path: Path) -> None:
        result = install(tmp_path)
        audit_path = tmp_path / ".ai-engineering" / "state" / "audit-log.ndjson"
        lines = audit_path.read_text().strip().splitlines()
        assert len(lines) == 1
        entry = json.loads(lines[0])
        assert entry["event"] == "install"
        assert entry["actor"] == "ai-engineering-cli"
        assert f"created={result.total_created}" in entry["detail"]


class TestInstallOnExistingRepo:
    """Tests for install() on a repo that already has some files."""

    def test_preserves_existing_files(self, tmp_path: Path) -> None:
        # Pre-create a team-managed file
        team_dir = tmp_path / ".ai-engineering" / "standards" / "team"
        team_dir.mkdir(parents=True)
        (team_dir / "core.md").write_text("custom team standard")

        install(tmp_path)

        # Team file preserved
        assert (team_dir / "core.md").read_text() == "custom team standard"

    def test_idempotent_install(self, tmp_path: Path) -> None:
        result1 = install(tmp_path)
        result2 = install(tmp_path)

        assert result1.total_created > 0
        # Second install creates nothing new (only audit log grows)
        assert result2.total_created == 0
        assert result2.total_skipped > 0

        # State files not duplicated
        assert len(result2.state_files) == 0

    def test_preserves_custom_claude_md(self, tmp_path: Path) -> None:
        (tmp_path / "CLAUDE.md").write_text("my custom CLAUDE")
        install(tmp_path)
        assert (tmp_path / "CLAUDE.md").read_text() == "my custom CLAUDE"


# ---------------------------------------------------------------------------
# Operations — add/remove stack/IDE
# ---------------------------------------------------------------------------


@pytest.fixture()
def installed_project(tmp_path: Path) -> Path:
    """Return a tmp_path with a completed installation."""
    install(tmp_path)
    return tmp_path


class TestAddStack:
    """Tests for add_stack operation."""

    def test_adds_new_stack(self, installed_project: Path) -> None:
        manifest = add_stack(installed_project, "node")
        assert "node" in manifest.installed_stacks
        assert "python" in manifest.installed_stacks

    def test_raises_on_duplicate_stack(self, installed_project: Path) -> None:
        with pytest.raises(InstallerError, match="already installed"):
            add_stack(installed_project, "python")

    def test_logs_audit_entry(self, installed_project: Path) -> None:
        add_stack(installed_project, "rust")
        audit = _read_audit_log(installed_project)
        stack_events = [e for e in audit if e["event"] == "stack-add"]
        assert len(stack_events) == 1
        assert "rust" in stack_events[0]["detail"]


class TestRemoveStack:
    """Tests for remove_stack operation."""

    def test_removes_existing_stack(self, installed_project: Path) -> None:
        manifest = remove_stack(installed_project, "python")
        assert "python" not in manifest.installed_stacks

    def test_raises_on_missing_stack(self, installed_project: Path) -> None:
        with pytest.raises(InstallerError, match="not installed"):
            remove_stack(installed_project, "nonexistent")


class TestAddIde:
    """Tests for add_ide operation."""

    def test_adds_new_ide(self, installed_project: Path) -> None:
        manifest = add_ide(installed_project, "vscode")
        assert "vscode" in manifest.installed_ides
        assert "terminal" in manifest.installed_ides

    def test_raises_on_duplicate_ide(self, installed_project: Path) -> None:
        with pytest.raises(InstallerError, match="already installed"):
            add_ide(installed_project, "terminal")


class TestRemoveIde:
    """Tests for remove_ide operation."""

    def test_removes_existing_ide(self, installed_project: Path) -> None:
        manifest = remove_ide(installed_project, "terminal")
        assert "terminal" not in manifest.installed_ides

    def test_raises_on_missing_ide(self, installed_project: Path) -> None:
        with pytest.raises(InstallerError, match="not installed"):
            remove_ide(installed_project, "nonexistent")


class TestListStatus:
    """Tests for list_status operation."""

    def test_returns_current_manifest(self, installed_project: Path) -> None:
        manifest = list_status(installed_project)
        assert isinstance(manifest, InstallManifest)
        assert "python" in manifest.installed_stacks

    def test_reflects_mutations(self, installed_project: Path) -> None:
        add_stack(installed_project, "go")
        manifest = list_status(installed_project)
        assert "go" in manifest.installed_stacks

    def test_raises_without_install(self, tmp_path: Path) -> None:
        with pytest.raises(InstallerError, match="not installed"):
            list_status(tmp_path)


class TestOperationsWithoutInstall:
    """Operations on uninstalled projects raise InstallerError."""

    def test_add_stack_raises(self, tmp_path: Path) -> None:
        with pytest.raises(InstallerError):
            add_stack(tmp_path, "python")

    def test_remove_stack_raises(self, tmp_path: Path) -> None:
        with pytest.raises(InstallerError):
            remove_stack(tmp_path, "python")

    def test_add_ide_raises(self, tmp_path: Path) -> None:
        with pytest.raises(InstallerError):
            add_ide(tmp_path, "vscode")

    def test_remove_ide_raises(self, tmp_path: Path) -> None:
        with pytest.raises(InstallerError):
            remove_ide(tmp_path, "vscode")


# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------


def _read_audit_log(project: Path) -> list[dict[str, object]]:
    """Read all audit-log entries as dicts."""
    audit_path = project / ".ai-engineering" / "state" / "audit-log.ndjson"
    if not audit_path.exists():
        return []
    return [
        json.loads(line)
        for line in audit_path.read_text().strip().splitlines()
        if line.strip()
    ]
